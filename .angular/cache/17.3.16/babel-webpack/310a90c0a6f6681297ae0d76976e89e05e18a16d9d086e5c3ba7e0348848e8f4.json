{"ast":null,"code":"import { HTTP_INTERCEPTORS } from '@angular/common/http';\nimport { of, throwError } from 'rxjs';\nimport { delay, materialize, dematerialize } from 'rxjs/operators';\nimport { Role } from '@app/_models';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@app/_services\";\n// array in local storage for accounts\nconst accountsKey = 'angular-10-signup-verification-boilerplate-accounts';\nlet accounts = JSON.parse(localStorage.getItem(accountsKey) || '[]');\nexport let FakeBackendInterceptor = /*#__PURE__*/(() => {\n  class FakeBackendInterceptor {\n    constructor(alertService) {\n      this.alertService = alertService;\n    }\n    intercept(request, next) {\n      const {\n        url,\n        method,\n        headers,\n        body\n      } = request;\n      const alertService = this.alertService;\n      return handleRoute();\n      function handleRoute() {\n        // Placeholder for routing logic\n        return next.handle(request);\n      }\n    }\n    static {\n      this.ɵfac = function FakeBackendInterceptor_Factory(t) {\n        return new (t || FakeBackendInterceptor)(i0.ɵɵinject(i1.AlertService));\n      };\n    }\n    static {\n      this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n        token: FakeBackendInterceptor,\n        factory: FakeBackendInterceptor.ɵfac\n      });\n    }\n  }\n  return FakeBackendInterceptor;\n})();\nfunction handleRoute() {\n  switch (true) {\n    case url.endsWith('/accounts/authenticate') && method === 'POST':\n      return authenticate();\n    case url.endsWith('/accounts/refresh-token') && method === 'POST':\n      return refreshToken();\n    case url.endsWith('/accounts/revoke-token') && method === 'POST':\n      return revokeToken();\n    case url.endsWith('/accounts/register') && method === 'POST':\n      return register();\n    case url.endsWith('/accounts/verify-email') && method === 'POST':\n      return verifyEmail();\n    case url.endsWith('/accounts/forgot-password') && method === 'POST':\n      return forgotPassword();\n    case url.endsWith('/accounts/validate-reset-token') && method === 'POST':\n      return validateResetToken();\n    case url.endsWith('/accounts/reset-password') && method === 'POST':\n      return resetPassword();\n    case url.endsWith('/accounts') && method === 'GET':\n      return getAccounts();\n    case url.match(/\\/accounts\\/\\d+$/) !== null && method === 'GET':\n      return getAccountById();\n    case url.endsWith('/accounts') && method === 'POST':\n      return createAccount();\n    case url.match(/\\/accounts\\/\\d+$/) !== null && method === 'PUT':\n      return updateAccount();\n    case url.match(/\\/accounts\\/\\d+$/) !== null && method === 'DELETE':\n      return deleteAccount();\n    default:\n      // pass through any requests not handled above\n      return next.handle(request);\n  }\n}\n// route functions\nfunction authenticate() {\n  const {\n    email,\n    password\n  } = body;\n  const account = accounts.find(x => x.email === email && x.password === password && x.isVerified);\n  if (!account) return error('Email or password is incorrect');\n  // add refresh token to account\n  account.refreshTokens.push(generateRefreshToken());\n  localStorage.setItem(accountsKey, JSON.stringify(accounts));\n  return ok({\n    ...basicDetails(account),\n    jwtToken: generateJwtToken(account)\n  });\n}\nfunction refreshToken() {\n  const refreshToken = getRefreshToken();\n  if (!refreshToken) return unauthorized();\n  const account = accounts.find(x => x.refreshTokens.includes(refreshToken));\n  if (!account) return unauthorized();\n  // replace old refresh token with a new one and save\n  account.refreshTokens = account.refreshTokens.filter(x => x !== refreshToken);\n  account.refreshTokens.push(generateRefreshToken());\n  localStorage.setItem(accountsKey, JSON.stringify(accounts));\n  return ok({\n    ...basicDetails(account),\n    jwtToken: generateJwtToken(account)\n  });\n}\nfunction revokeToken() {\n  if (!isAuthenticated()) return unauthorized();\n  const refreshToken = getRefreshToken();\n  const account = accounts.find(x => x.refreshTokens.includes(refreshToken));\n  // revoke token and save\n  account.refreshTokens = account.refreshTokens.filter(x => x !== refreshToken);\n  localStorage.setItem(accountsKey, JSON.stringify(accounts));\n  return ok();\n}\n// display verification email in alert\nsetTimeout(() => {\n  const account = body;\n  if (accounts.find(x => x.email === account.email)) {\n    // display email already registered \"email\" in alert\n    setTimeout(() => {\n      alertService.info(`\n                <h4>Already Registered</h4>\n                <p>Your email ${account.email} is already registered.</p>\n                <p>If you don't know your password please visit the <a href=\"${location.origin}/account/forgot-password\">forgot password</a> page.</p>\n                <div><strong>NOTE:</strong> The fake backend displayed this \"email\" so you can test without an api. A real backend would send a real email.</div>\n            `, {\n        autoClose: false\n      });\n    }, 1000);\n    // display return ok() response to prevent email enumeration\n    return ok();\n  }\n  // assign account id and a few other properties then save\n  account.id = newAccountId();\n  if (account.id === 1) {\n    // first registered account is an admin\n    account.role = Role.Admin;\n  } else {\n    account.role = Role.User;\n  }\n  account.dateCreated = new Date().toISOString();\n  account.verificationToken = new Date().getTime().toString();\n  account.isVerified = false;\n  account.refreshTokens = [];\n  delete account.confirmPassword;\n  accounts.push(account);\n  localStorage.setItem(accountsKey, JSON.stringify(accounts));\n  // display verification email in alert\n  setTimeout(() => {\n    const verifyUrl = `${location.origin}/account/verify-email?token=${account.verificationToken}`;\n    alertService.info(`\n            <h4>Verification Email</h4>\n            <p>Thanks for registering!</p>\n            <p>Please click the below link to verify your email address.</p>\n            <p><a href=\"${verifyUrl}\">${verifyUrl}</a></p>\n            <div><strong>NOTE:</strong> The fake backend displayed this \"email\" so you can test without an api. A real backend would send a real email.</div>\n        `, {\n      autoClose: false\n    });\n  }, 1000);\n  return ok();\n});\nfunction verifyEmail() {\n  const {\n    token\n  } = body;\n  const account = accounts.find(x => x.verificationToken && x.verificationToken === token);\n  if (!account) return error('Verification failed');\n  // set is verified flag to true if token is valid\n  account.isVerified = true;\n  localStorage.setItem(accountsKey, JSON.stringify(accounts));\n  return ok();\n}\nfunction forgetPassword() {\n  const {\n    email\n  } = body;\n  const account = accounts.find(x => x.email === email);\n  // always return ok() response to prevent email enumeration\n  if (!account) return ok();\n  // create reset token that expires after 24 hours\n  account.resetToken = new Date().getTime().toString();\n  account.resetTokenExpires = new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString();\n  localStorage.setItem(accountsKey, JSON.stringify(accounts));\n  // display password reset email in alert\n  setTimeout(() => {\n    const resetUrl = `${location.origin}/account/reset-password?token=${account.resetToken}`;\n    alertService.info(`\n            <h4>Reset Password Email</h4>\n            <p>Please click the below link to reset your password, the link will be valid for 1 day</p>\n            <p><a href=\"${resetUrl}\">${resetUrl}</a></p>\n            <div><strong>NOTE:</strong> The fake backend displayed this \"email\" so you can test without an api. A real backend would send a real email.</div>\n        `, {\n      autoClose: false\n    });\n  }, 1000);\n  return ok();\n}\nfunction validateResetToken() {\n  const {\n    token\n  } = body;\n  const account = accounts.find(x => x.resetToken && x.resetToken === token && new Date() < new Date(x.resetTokenExpires));\n  if (!account) return error('Invalid token');\n  return ok();\n}\nfunction resetPassword() {\n  const {\n    token,\n    password\n  } = body;\n  const account = accounts.find(x => x.resetToken && x.resetToken === token && new Date() < new Date(x.resetTokenExpires));\n  if (!account) return error('Invalid token');\n  // update password and remove reset token\n  account.password = password;\n  account.isVerified = true;\n  delete account.resetToken;\n  delete account.resetTokenExpires;\n  localStorage.setItem(accountsKey, JSON.stringify(accounts));\n  return ok();\n}\nfunction getAccounts() {\n  if (!isAuthenticated()) return unauthorized();\n  return ok(accounts.map(x => basicDetails(x)));\n}\nfunction getAccountById() {\n  if (!isAuthenticated()) return unauthorized();\n  let account = accounts.find(x => x.id === idFromUrl());\n  if (!account) return notFound();\n  // user accounts can get own profile and admin accounts can get all profiles\n  if (account.id !== currentAccount().id && !isAuthorized(Role.Admin)) {\n    return unauthorized();\n  }\n  return ok(basicDetails(account));\n}\nfunction createAccount() {\n  if (!isAuthorized(Role.Admin)) return unauthorized();\n  const account = body;\n  if (accounts.find(x => x.email === account.email)) {\n    return error(`Email ${account.email} is already registered`);\n  }\n  // assign account id and a few other properties then save\n  account.id = newAccountId();\n  account.dateCreated = new Date().toISOString();\n  account.isVerified = true;\n  account.refreshTokens = [];\n  delete account.confirmPassword;\n  accounts.push(account);\n  localStorage.setItem(accountsKey, JSON.stringify(accounts));\n  return ok(basicDetails(account));\n}\nfunction updateAccount() {\n  if (!isAuthenticated()) return unauthorized();\n  let params = body;\n  let account = accounts.find(x => x.id === idFromUrl());\n  if (!account) return notFound();\n  // user accounts can update own profile and admin accounts can update all profiles\n  if (account.id !== currentAccount().id && !isAuthorized(Role.Admin)) {\n    return unauthorized();\n  }\n  // only update password if included\n  if (!params.password) {\n    delete params.password;\n  }\n  // don't save confirm password\n  delete params.confirmPassword;\n  // update and save account\n  Object.assign(account, params);\n  localStorage.setItem(accountsKey, JSON.stringify(accounts));\n  return ok(basicDetails(account));\n}\nfunction deleteAccount() {\n  if (!isAuthenticated()) return unauthorized();\n  let account = accounts.find(x => x.id === idFromUrl());\n  if (!account) return notFound();\n  // user accounts can delete own account and admin accounts can delete any account\n  if (account.id !== currentAccount().id && !isAuthorized(Role.Admin)) {\n    return unauthorized();\n  }\n  // delete account then save\n  accounts = accounts.filter(x => x.id !== idFromUrl());\n  localStorage.setItem(accountsKey, JSON.stringify(accounts));\n  return ok();\n}\n// helper functions\nfunction ok(body) {\n  return of({\n    status: 200,\n    body\n  }).pipe(delay(500)); // delay observable to simulate server api call\n}\nfunction error(message) {\n  return throwError(() => ({\n    status: 400,\n    error: {\n      message\n    }\n  })).pipe(materialize(), delay(500), dematerialize());\n  // call materialize and dematerialize to ensure delay even if an error is thrown\n}\nfunction unauthorized() {\n  return throwError(() => ({\n    status: 401,\n    error: {\n      message: 'Unauthorized'\n    }\n  })).pipe(materialize(), delay(500), dematerialize());\n}\nfunction basicDetails(account) {\n  const {\n    id,\n    title,\n    firstName,\n    lastName,\n    email,\n    role,\n    dateCreated,\n    isVerified\n  } = account;\n  return {\n    id,\n    title,\n    firstName,\n    lastName,\n    email,\n    role,\n    dateCreated,\n    isVerified\n  };\n}\nfunction isAuthenticated() {\n  return !!currentAccount();\n}\nfunction isAuthorized(role) {\n  const account = currentAccount();\n  if (!account) return false;\n  return account.role === role;\n}\nfunction idFromUrl() {\n  const urlParts = window.location.pathname.split('/');\n  return parseInt(urlParts[urlParts.length - 1]);\n}\nfunction newAccountId() {\n  return accounts.length ? Math.max(...accounts.map(x => x.id)) + 1 : 1;\n}\nfunction currentAccount() {\n  // check if jwt token is in auth header\n  const authHeader = headers.get('Authorization');\n  if (!authHeader?.startsWith('Bearer fake-jwt-token')) return null;\n  // check if token is expired\n  const jwtToken = JSON.parse(atob(authHeader.split('.')[1]));\n  const tokenExpired = Date.now() > jwtToken.exp * 1000;\n  if (tokenExpired) return null;\n  const account = accounts.find(x => x.id === jwtToken.id);\n  return account;\n}\nfunction generateJwtToken(account) {\n  // create token that expires in 15 minutes\n  const tokenPayload = {\n    exp: Math.round(new Date(Date.now() + 15 * 60 * 1000).getTime() / 1000),\n    id: account.id\n  };\n  return `fake-jwt-token.${btoa(JSON.stringify(tokenPayload))}`;\n}\nfunction generateRefreshToken() {\n  const token = new Date().getTime().toString();\n  // add token cookie that expires in 7 days\n  const expires = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000).toUTCString();\n  document.cookie = `fakeRefreshToken=${token}; expires=${expires}; path=/`;\n  return token;\n}\nfunction getRefreshToken() {\n  // get refresh token from cookie\n  const cookie = document.cookie.split(';').find(x => x.includes('fakeRefreshToken')) || '=';\n  return cookie.split('=')[1];\n}\nexport const fakeBackendProvider = {\n  // use fake backend in place of Http service for backend-less development\n  provide: HTTP_INTERCEPTORS,\n  useClass: FakeBackendInterceptor,\n  multi: true\n};","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}